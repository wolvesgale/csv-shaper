<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CSV整形（姓名分割・列合わせ）</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='28' fill='%2338bdf8'/%3E%3Ctext x='32' y='40' font-size='28' text-anchor='middle' fill='%2304202b'%3EC%3C/text%3E%3C/svg%3E" />
  <style>
    :root { --bg:#0b1220; --panel:#0f172a; --text:#e5e7eb; --muted:#94a3b8; --accent:#38bdf8; }
    body { margin:0; background:var(--bg); color:var(--text); font:14px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif; }
    header { padding:16px 20px; border-bottom:1px solid #1f2937; position:sticky; top:0; background:linear-gradient(0deg, rgba(15,23,42,0.2), rgba(15,23,42,0.9)); backdrop-filter:blur(8px); }
    h1 { font-size:18px; margin:0; letter-spacing:.02em }
    main { max-width:1100px; margin:24px auto; padding:0 16px; }
    .card { background:var(--panel); border:1px solid #1f2937; border-radius:16px; padding:16px; margin-bottom:16px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .col { flex:1 1 320px; }
    label { display:block; font-weight:600; margin-bottom:6px; color:var(--muted) }
    input[type="file"], select, button { width:100%; padding:10px 12px; border-radius:12px; border:1px solid #243041; background:#0b1220; color:#e5e7eb; }
    button.primary { background:var(--accent); color:#04202b; border:none; font-weight:700; }
    button:disabled { opacity:.5 }
    .muted { color:var(--muted) }
    .pill { display:inline-flex; align-items:center; gap:6px; border:1px solid #243041; border-radius:999px; padding:4px 10px; margin:4px 8px 0 0; font-size:12px; color:#93c5fd }
    table { width:100%; border-collapse:collapse; font-size:12px; }
    th, td { border-bottom:1px solid #1f2937; padding:6px 8px; text-align:left; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .footer { margin-top:24px; color:var(--muted); font-size:12px }
    details { border:1px dashed #243041; border-radius:12px; padding:10px 12px; }
    summary { cursor:pointer; color:#93c5fd; font-weight:600 }
  </style>
</head>
<body>
  <header><h1>CSV整形（姓名分割・サンプル列準拠）</h1></header>
  <main>

    <div class="card">
      <div class="row">
        <div class="col">
          <label>① サンプルCSV（ターゲット列定義）</label>
          <input id="sampleCsv" type="file" accept=".csv" />
          <p class="muted">※ <code>admin-customer-list-sample.csv</code> を指定。未指定で取得失敗時は既定列を使用。</p>
          <div id="sampleStatus" class="muted" style="margin-top:6px"></div>
        </div>
        <div class="col">
          <label>② 変換する元CSV（人脈リスト）</label>
          <input id="sourceCsv" type="file" accept=".csv" />
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>文字コード（入力CSV）</label>
          <select id="inputEncoding">
            <option value="auto" selected>自動判定（推奨）</option>
            <option value="utf-8">UTF-8</option>
            <option value="shift_jis">Shift_JIS（CP932系）</option>
          </select>
          <p class="muted">※ 文字化けする場合は Shift_JIS を明示してください。</p>
          <div id="encodingStatus" class="muted" style="margin-top:6px"></div>
        </div>
        <div class="col">
          <label>フルネーム列（氏名/姓名など）</label>
          <select id="fullNameCol">
            <option value="">自動検出（氏名/姓名/名前/Name）</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>オプション</label>
          <div>
            <span class="pill"><input id="stripAscii" type="checkbox" checked> 漢字＋英字 → 英字のみ削除（スペースは保持）</span>
            <span class="pill"><input id="keepSpaces" type="checkbox" checked> 分割は最初の半角スペースのみ（右側の空白は保持）</span>
            <span class="pill"><input id="useZenkaku" type="checkbox" checked> 全角スペースも分割対象</span>
            <span class="pill"><input id="useHeuristic" type="checkbox" checked> スペース無しは推定分割</span>
          </div>
        </div>
      </div>

      <div class="row"><div class="col"><button id="convertBtn" class="primary" disabled>③ 変換してダウンロード（UTF-8-SIG）</button></div></div>
    </div>

    <div class="card">
      <div class="row">
        <div class="col">
          <label>サンプル列プレビュー</label>
          <div id="sampleCols" class="muted">未読込</div>
        </div>
        <div class="col">
          <label>入力CSV：先頭行プレビュー</label>
          <div style="overflow:auto; max-height:260px"><table id="previewTable"></table></div>
        </div>
      </div>
    </div>

    <details class="card">
      <summary>仕様（クリックで展開）</summary>
      <ul>
        <li>サンプル列に<strong>完全準拠</strong>（無い列は破棄／足りない列は空欄補完）。</li>
        <li>姓/名が別列なら<strong>そのまま採用</strong>（最後に空欄のみ「未入力」補完）。</li>
        <li>氏名1列は半角/全角スペース・タブ・中点・スラッシュを区切りに分割。不可なら推定分割。</li>
        <li>会社名/部署/役職は文面から推定して配置。</li>
        <li>サンプル未指定時は既定列：<code>company_name, company_number, last_name, first_name, department, position, contact_url, notes, supporter_id</code></li>
        <li>2500件超は<strong>2500件ごと</strong>に自動分割出力。</li>
        <li>元CSV内の Facebook URL を <code>contact_url</code> に反映（既にURLがある場合は notes に追記）。</li>
        <li>first_name だけ埋まっていて last_name が空、かつ first_name が「フルネームっぽい」場合は分割して補正。</li>
        <li><strong>追加</strong>：入力CSVの文字コードを自動判定（UTF-8/Shift_JIS）。</li>
      </ul>
    </details>

    <div class="footer">No server / static. Deploy anywhere.</div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    const sampleInput = document.getElementById('sampleCsv');
    const sourceInput = document.getElementById('sourceCsv');
    const fullNameColSelect = document.getElementById('fullNameCol');
    const convertBtn = document.getElementById('convertBtn');
    const sampleColsDiv = document.getElementById('sampleCols');
    const previewTable = document.getElementById('previewTable');
    const stripAscii = document.getElementById('stripAscii');
    const keepSpaces = document.getElementById('keepSpaces');
    const useZenkaku = document.getElementById('useZenkaku');
    const useHeuristic = document.getElementById('useHeuristic');
    const sampleStatus = document.getElementById('sampleStatus');
    const inputEncoding = document.getElementById('inputEncoding');
    const encodingStatus = document.getElementById('encodingStatus');

    const DEFAULT_TARGET_HEADERS = [
      'company_name','company_number','last_name','first_name','department','position','contact_url','notes','supporter_id'
    ];

    const headerMap = {
      '会社名':'company_name','社名':'company_name','企業名':'company_name','法人名':'company_name','勤務先':'company_name','勤務先名':'company_name',
      '会社番号':'company_number',
      '部署':'department','部門':'department','所属':'department','部署名':'department',
      '役職':'position','役割':'position','肩書':'position','職位':'position','職名':'position',
      'URL':'contact_url','連絡先':'contact_url','Web':'contact_url','WEB':'contact_url','website':'contact_url','Website':'contact_url',
      '備考':'notes','メモ':'notes','注記':'notes',
      'サポーターID':'supporter_id','supporterId':'supporter_id',

      'Facebook':'contact_url','facebook':'contact_url','FB':'contact_url','fb':'contact_url',
      'Facebook URL':'contact_url','facebook url':'contact_url','FacebookURL':'contact_url','fb url':'contact_url',
      'Facebookリンク':'contact_url','Facebookリンク先':'contact_url','FacebookのURL':'contact_url','フェイスブック':'contact_url',

      '姓':'last_name','苗字':'last_name','名字':'last_name',
      '名':'first_name','名前':'first_name',
      '名(あれば)':'first_name','名（あれば）':'first_name','名(任意)':'first_name','名（任意）':'first_name',

      'Last Name':'last_name','LAST NAME':'last_name','last name':'last_name','last_name':'last_name','LastName':'last_name','Surname':'last_name','SURNAME':'last_name',
      'First Name':'first_name','FIRST NAME':'first_name','first name':'first_name','first_name':'first_name','FirstName':'first_name','Given Name':'first_name','GIVEN NAME':'first_name'
    };

    const POSITION_KEYWORDS = /(取締役|代表|社長|副社長|CEO|COO|CTO|CFO|CIO|Chief|会長|専務|常務|本部長|部長|次長|課長|マネージャ|Manager|Lead|リーダ|主任|役員|顧問|Advisor|部門長)/i;
    const DEPT_KEYWORDS     = /(本部|部|課|室|センター|事業部|営業部|総務部|人事部|経理部|財務部|開発部|マーケティング|広報|法務|カスタマーサクセス|CS|企画|品質|製造|DX|IT|情報システム|情報企画)/i;

    const SURNAMES = new Set(['佐藤','鈴木','高橋','田中','伊藤','渡辺','山本','中村','小林','加藤','吉田','山田','佐々木','山口','斎藤','斉藤','井上','木村','林','清水','山崎','阿部','森','池田','橋本','石川','山下','中島','小川','前田','岡田','長谷川','村上','藤田','後藤','小野','松本','近藤','石井','坂本','遠藤','青木','藤井','西村','福田','太田','三浦','中野','中川','松田','竹内','小島','田村','金子','和田','石田','中山','原田','酒井','工藤','池上','大西','本田','宮本','平井','柴田','黒田','北村','島田','岩田','菅原','西田','内田','秋山','安田','星野']);

    const EMPTY_NAME_TOKENS = new Set(['', '未入力', 'false', 'FALSE', 'False', 'na', 'NA', '-', 'ー', 'N/A']);

    const stripBOM = s => (typeof s === 'string' ? s.replace(/^\uFEFF/, '') : s);
    const z2hParens = s => s.replace(/[（]/g,'(').replace(/[）]/g,')');
    const normKey = k => z2hParens(stripBOM(String(k||'')).trim());

    let sampleHeaders = [];
    let sourceRows = [];

    function setButtonState(){ convertBtn.disabled = !(sampleHeaders.length && sourceRows.length); }

    function tryAutoFullNameCol(headers){
      const keys = ['氏名','姓名','名前','お名前','Name','name','フルネーム','Full Name','full_name','FullName'];
      const hit = headers.find(h => {
        const k = stripBOM(h);
        return keys.some(t => k.includes(t));
      });
      return hit || '';
    }

    function renderPreview(){
      previewTable.innerHTML = '';
      if(!sourceRows.length) return;
      const headers = Object.keys(sourceRows[0] || {});
      const thead = document.createElement('thead');
      const tr = document.createElement('tr');
      headers.forEach(h => { const th = document.createElement('th'); th.textContent = h; tr.appendChild(th); });
      thead.appendChild(tr); previewTable.appendChild(thead);
      const tbody = document.createElement('tbody');
      sourceRows.slice(0,10).forEach(row=>{
        const tr = document.createElement('tr');
        headers.forEach(h => { const td = document.createElement('td'); td.textContent = row[h] ?? ''; tr.appendChild(td); });
        tbody.appendChild(tr);
      });
      previewTable.appendChild(tbody);
    }

    function deriveSuffixFromSourceName(filename) {
      if (!filename) return '';
      const base = filename.replace(/\.[^.]+$/, '');
      const withoutJinmyaku = base.replace(/人脈/g, '');
      const kanjiChars = (withoutJinmyaku.match(/[\u4E00-\u9FFF]/g) || []).join('');
      if (kanjiChars.length > 0) return sanitizeForFilename(kanjiChars);
      const tokens = base.split(/[^A-Za-z]+/).filter(Boolean).filter(t => !/^(rp|xx)$/i.test(t)).filter(t => !/^\d+$/.test(t));
      if (tokens.length === 0) return '';
      return sanitizeForFilename(tokens.join('_'));
    }
    function sanitizeForFilename(s) {
      const cleaned = s.replace(/[\\/:*?"<>|]/g, '').replace(/\s+/g, '');
      return cleaned.slice(0, 80);
    }

    const NAME_DELIM = /[\t \/　・／]+/;

    function heuristicSplitKanji(s){
      for(const ln of Array.from(SURNAMES).sort((a,b)=>b.length-a.length)){
        if(s.startsWith(ln)) return { last: ln, first: s.slice(ln.length) };
      }
      const kanji = (s.match(/[\u4E00-\u9FFF]/g) || []).length;
      if (kanji <= 2) return { last: s, first: '' };
      if(kanji >= 4) return { last: s.slice(0,2), first: s.slice(2) };
      if(kanji === 3) return { last: s.slice(0,1), first: s.slice(1) };
      const mid = Math.max(1, Math.floor(s.length/2));
      return { last: s.slice(0,mid), first: s.slice(mid) };
    }

    function normalizeName(raw){
      if (raw == null) return { last: '', first: '' };
      let s = String(raw).trim();
      if (EMPTY_NAME_TOKENS.has(s)) return { last: '', first: '' };

      if (NAME_DELIM.test(s)) {
        const parts = s.split(NAME_DELIM).filter(Boolean);
        if (parts.length >= 2) return { last: parts[0].trim(), first: parts.slice(1).join(' ').trim() };
      }

      const hasKanji = /[\u4E00-\u9FFF]/.test(s);
      const hasLatin = /[A-Za-z]/.test(s);

      if (hasKanji) {
        if (stripAscii.checked) s = s.replace(/[A-Za-z\-_'`~!@#\$%\^&*()=+\[\]{}|;:\",.<>?]+/g, '').trim();
        let i = s.indexOf(' ');
        if (i >= 0) return { last: s.slice(0,i).trim(), first: s.slice(i+1).trim() };
        let j = s.indexOf('　');
        if (j >= 0) return { last: s.slice(0,j).trim(), first: s.slice(j+1).trim() };
        if (useHeuristic && useHeuristic.checked) return heuristicSplitKanji(s);
        return { last: s, first: '' };
      }

      if (hasLatin) {
        s = s.replace(/\s+/g, ' ').trim();
        const j = s.lastIndexOf(' ');
        if (j === -1) return { last: s, first: '' };
        return { first: s.slice(0, j).trim(), last: s.slice(j + 1).trim() };
      }

      const k = s.indexOf(' ');
      if (k >= 0) return { last: s.slice(0,k).trim(), first: s.slice(k+1).trim() };
      const l = s.indexOf('　');
      if (l >= 0) return { last: s.slice(0,l).trim(), first: s.slice(l+1).trim() };
      return { last: s, first: '' };
    }

    function pickSeparateNames(row){
      const keys = Object.keys(row || {});
      let lastKey = null;
      let firstKey = null;

      for (const rawKey of keys) {
        const k = normKey(rawKey);
        const isCompanyLikeHeader = /会社名|企業名|法人名|勤務先/.test(k);

        if (!lastKey) {
          if (k === '姓' || k === '苗字' || k === '名字' || /^姓\(/.test(k) || /^姓（/.test(k)) lastKey = rawKey;
        }
        if (!firstKey && !isCompanyLikeHeader) {
          if (
            k === '名' || k === '名前' ||
            /^名\(/.test(k) || /^名（/.test(k) ||
            k === '名あれば' || k === '名(あれば)' || k === '名（あれば）'
          ) firstKey = rawKey;
        }
      }

      const last  = lastKey  ? String(row[lastKey]  ?? '').trim() : '';
      const first = firstKey ? String(row[firstKey] ?? '').trim() : '';

      const bothEmpty = EMPTY_NAME_TOKENS.has(last) && EMPTY_NAME_TOKENS.has(first);
      const onlyOneSide = (!!lastKey ^ !!firstKey);
      const oneVal = lastKey && !firstKey ? last : (!lastKey && firstKey ? first : '');
      const looksFull = NAME_DELIM.test(oneVal);

      if (onlyOneSide && looksFull) return { last: '', first: '', found: false };
      if (lastKey || firstKey) return { last: bothEmpty ? '' : last, first: bothEmpty ? '' : first, found: true };
      return { last: '', first: '', found: false };
    }

    function looksCompanyLike(text){
      if(!text) return false;
      return /(株式会社|有限会社|合同会社|合資会社|合名会社|Inc\.?|LLC|GmbH|Ltd\.?|Co\.|Company|Holdings|HD|大学|研究所|機構|財団|社団)/i.test(text);
    }

    function cleanCompanyName(text){
      if(!text) return '';
      let s = String(text).trim();
      const m = s.match(DEPT_KEYWORDS);
      if (m && m.index > 0) s = s.slice(0, m.index).trim();
      return s;
    }

    function looksPositionLike(text){ return POSITION_KEYWORDS.test(text || ''); }
    function looksDepartmentLike(text){ return DEPT_KEYWORDS.test(text || ''); }

    function maybeSwapName(lastVal, firstVal){
      const l = String(lastVal ?? '').trim();
      const f = String(firstVal ?? '').trim();

      if (!l || !f) return { last: l, first: f };
      if (EMPTY_NAME_TOKENS.has(l) || EMPTY_NAME_TOKENS.has(f)) return { last: l, first: f };
      if (looksCompanyLike(l) || looksCompanyLike(f)) return { last: l, first: f };

      const lastIsSurname = SURNAMES.has(l);
      const firstIsSurname = SURNAMES.has(f);

      if (firstIsSurname && !lastIsSurname) return { last: f, first: l };
      return { last: l, first: f };
    }

    // ===== Facebook URL 抽出（強化版）=====
    const FB_URL_RE = /((https?:\/\/)?(www\.)?((m|mbasic)\.)?(facebook\.com|fb\.com|fb\.me)\/[^\s"'<>，,]+)(?=$|[\s"'<>，,])/i;

    function normalizeUrl(u){
      if(!u) return '';
      let s = String(u).trim();
      if(!s) return '';
      s = s.replace(/[)\]】』」]+$/g, '').trim();
      if (/^www\./i.test(s)) s = 'https://' + s;
      if (!/^https?:\/\//i.test(s)) {
        if (/^((m|mbasic)\.)?facebook\.com\//i.test(s) || /^fb\.(com|me)\//i.test(s)) s = 'https://' + s;
      }
      return s;
    }

    function extractFacebookUrlFromRow(row){
      const keys = Object.keys(row || {});
      for (const k of keys) {
        const nk = normKey(k).toLowerCase();
        if (nk.includes('facebook') || nk === 'fb' || nk.includes('フェイスブック')) {
          const raw = String(row[k] ?? '').trim();
          if (!raw) continue;
          const m = raw.match(FB_URL_RE);
          if (m) return normalizeUrl(m[1]);
        }
      }
      for (const k of keys) {
        const raw = String(row[k] ?? '').trim();
        if (!raw) continue;
        if (!/facebook\.com|fb\.com|fb\.me/i.test(raw)) continue;
        const m = raw.match(FB_URL_RE);
        if (m) return normalizeUrl(m[1]);
      }
      return '';
    }

    function appendToNotes(outRow, text){
      if (!text) return;
      const cur = String(outRow['notes'] ?? '').trim();
      if (!cur) { outRow['notes'] = text; return; }
      if (cur.includes(text)) return;
      outRow['notes'] = cur + '\n' + text;
    }
    // ===== ここまで Facebook URL =====

    // ★追加：first_name しか埋まってない場合に「フルネーム扱い」で分割すべきか
    function shouldReSplitFirstOnly(firstVal){
      const s = String(firstVal ?? '').trim();
      if(!s) return false;
      if(EMPTY_NAME_TOKENS.has(s)) return false;
      if(looksCompanyLike(s)) return false;
      return NAME_DELIM.test(s);
    }

    function adoptHeadersFromSample(meta){
      if(meta && meta.fields && meta.fields.length){
        sampleHeaders = meta.fields;
        sampleColsDiv.textContent = sampleHeaders.join(' | ');
        sampleStatus.textContent = 'サンプルCSVを使用中';
      }else{
        sampleHeaders = DEFAULT_TARGET_HEADERS.slice();
        sampleColsDiv.textContent = sampleHeaders.join(' | ');
        sampleStatus.textContent = 'サンプルCSVが見つからないため既定列を使用中';
      }
    }

    // ========= ここから：文字コード対応（追加要件） =========

    function scoreMojibake(text){
      if(!text) return 0;
      const rep = (text.match(/\uFFFD/g) || []).length; // �
      const odd = (text.match(/[�]/g) || []).length;    // 念のため
      const typical = (text.match(/(縺|繧|繝|蟯|螳|驛|髮|譁|邨|險)/g) || []).length; // 典型的な化け（目安）
      return rep * 10 + odd * 10 + typical * 2;
    }

    async function readFileTextWithEncoding(file, enc){
      const ab = await file.arrayBuffer();
      const normalizeEnc = (e) => {
        if (!e) return 'utf-8';
        if (e === 'shift_jis') return 'shift-jis';
        return e;
      };

      const decode = (encoding) => {
        const dec = new TextDecoder(encoding, { fatal: false });
        return dec.decode(ab);
      };

      if (enc && enc !== 'auto') {
        return { text: decode(normalizeEnc(enc)), used: enc };
      }

      // auto: utf-8 → だめそうなら shift-jis
      const utf8 = decode('utf-8');
      const s1 = scoreMojibake(utf8);
      const sjis = decode('shift-jis');
      const s2 = scoreMojibake(sjis);

      // score が低い方を採用
      if (s2 + 1 < s1) return { text: sjis, used: 'shift_jis' };
      return { text: utf8, used: 'utf-8' };
    }

    async function parseFile(file, onDone){
      const { text, used } = await readFileTextWithEncoding(file, inputEncoding.value);
      encodingStatus.textContent = `入力CSVは「${used === 'shift_jis' ? 'Shift_JIS' : 'UTF-8'}」として読込（自動/指定）`;

      const res = Papa.parse(text, {
        header: true,
        skipEmptyLines: 'greedy'
      });

      const rows = (res.data || []).map(r=>{
        const o = {};
        for(const k in r){
          const nk = stripBOM(k);
          o[nk] = r[k];
        }
        return o;
      });

      onDone(rows, res.meta || {});
    }

    // ========= ここまで：文字コード対応 =========

    async function fetchLocalSampleFallback(){
      try{
        const resp = await fetch('./admin-customer-list-sample.csv',{ credentials:'same-origin' });
        if(!resp.ok) throw new Error('fetch failed');
        const text = await resp.text();
        const parsed = Papa.parse(text,{ header:true });
        adoptHeadersFromSample(parsed.meta);
      }catch(_){
        adoptHeadersFromSample({});
      }finally{
        setButtonState();
      }
    }

    // 入力CSV読み込み
    sourceInput.addEventListener('change', async () => {
      const f = sourceInput.files && sourceInput.files[0];
      if (!f) return;

      await parseFile(f, (rows) => {
        sourceRows = rows;
        renderPreview();

        const headers = Object.keys(rows[0] || {});
        fullNameColSelect.innerHTML =
          '<option value="">自動検出（氏名/姓名/名前/Name）</option>' +
          headers.map((h) => `<option>${h}</option>`).join('');

        let detected = tryAutoFullNameCol(headers);
        if (!detected && headers.length > 0) detected = headers[0];
        fullNameColSelect.value = detected || '';
        setButtonState();
      });
    });

    // サンプルCSV読み込み（文字コード対応）
    sampleInput.addEventListener('change', async()=>{
      const f = sampleInput.files && sampleInput.files[0];
      if(!f) return;
      await parseFile(f, (_rows, meta) => {
        // 列定義用なので preview だけ欲しい → meta.fields を採用
        adoptHeadersFromSample(meta || {});
        setButtonState();
      });
    });

    // エンコーディング変更時：読み込み済みファイルがあるなら再読込できるようにする（破壊しない）
    inputEncoding.addEventListener('change', async()=>{
      const f = sourceInput.files && sourceInput.files[0];
      if (!f) return;
      await parseFile(f, (rows) => {
        sourceRows = rows;
        renderPreview();
        const headers = Object.keys(rows[0] || {});
        fullNameColSelect.innerHTML =
          '<option value="">自動検出（氏名/姓名/名前/Name）</option>' +
          headers.map((h) => `<option>${h}</option>`).join('');
        let detected = tryAutoFullNameCol(headers);
        if (!detected && headers.length > 0) detected = headers[0];
        fullNameColSelect.value = detected || '';
        setButtonState();
      });
    });

    function saveCsvChunks(rows, srcFileName, sampleHeaders){
      const suffix  = deriveSuffixFromSourceName(srcFileName);
      const base    = 'converted_admin_customer_list';
      const chunkSize = 2500;
      const total = rows.length;
      const chunks = Math.ceil(total / chunkSize);

      for(let i=0;i<chunks;i++){
        const slice = rows.slice(i*chunkSize, (i+1)*chunkSize);
        const csv = Papa.unparse(
          { fields: sampleHeaders, data: slice.map(r => sampleHeaders.map(h => r[h] ?? '')) },
          { quotes:true, newline:"\n" }
        );
        const BOM  = new Uint8Array([0xEF,0xBB,0xBF]);
        const blob = new Blob([BOM, csv], { type:'text/csv' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const tag = (chunks>1) ? `_part${String(i+1).padStart(2,'0')}of${String(chunks).padStart(2,'0')}` : '';
        a.download = `${base}${suffix ? '_' + suffix : ''}${tag}.csv`;
        a.click();
        URL.revokeObjectURL(a.href);
      }
    }

    convertBtn.addEventListener('click', ()=>{
      if(!sampleHeaders.length || !sourceRows.length) return;

      const headers = Object.keys(sourceRows[0] || {});
      const fullNameKey =
        fullNameColSelect.value ||
        tryAutoFullNameCol(headers) ||
        (headers[0] || '');

      const out = [];

      const outLastKey  = sampleHeaders.includes('last_name')  ? 'last_name'  : (sampleHeaders.includes('姓') ? '姓' : null);
      const outFirstKey = sampleHeaders.includes('first_name') ? 'first_name' : (sampleHeaders.includes('名') ? '名' : null);

      for(const row of sourceRows){
        const outRow = Object.fromEntries(sampleHeaders.map(h=>[h,'']));

        // 1) ヘッダ一致はコピー
        for(const h of sampleHeaders){ if(h in row) outRow[h] = row[h]; }

        // 1.5) 表記ゆれマッピング
        for(const [jp,en] of Object.entries(headerMap)){
          if(en && sampleHeaders.includes(en) && (jp in row) && String(row[jp]??'').trim()!==''){
            let v = row[jp];
            if (en === 'company_name') v = cleanCompanyName(v);
            outRow[en] = v;
          }
        }

        // 1.8) 会社/部署/役職の推定補完
        if(sampleHeaders.includes('company_name') && !outRow['company_name']){
          const keys = Object.keys(row||{});
          for(let k of keys){
            const v = String(row[k] ?? '').trim();
            if(!v) continue;
            if(looksCompanyLike(v)){ outRow['company_name']=cleanCompanyName(v); break; }
          }
        }
        if(sampleHeaders.includes('position') && !outRow['position']){
          const keys = Object.keys(row||{});
          for(let k of keys){
            const v = String(row[k] ?? '').trim();
            if(looksPositionLike(v)){ outRow['position']=v; break; }
          }
        }
        if(sampleHeaders.includes('department') && !outRow['department']){
          const keys = Object.keys(row||{});
          const depts = [];
          for(let k of keys){
            const v = String(row[k] ?? '').trim();
            if(looksDepartmentLike(v)) depts.push(v);
          }
          if(depts.length) outRow['department'] = Array.from(new Set(depts)).join('\n');
        }

        // 2) 氏名決定
        let lastVal  = outLastKey  ? String(outRow[outLastKey]  ?? '').trim() : '';
        let firstVal = outFirstKey ? String(outRow[outFirstKey] ?? '').trim() : '';

        const hasLast  = !!lastVal  && !EMPTY_NAME_TOKENS.has(lastVal);
        const hasFirst = !!firstVal && !EMPTY_NAME_TOKENS.has(firstVal);

        // first_name だけ埋まっていて last_name が空、かつ first がフルネームっぽい → そこから分割
        if (!hasLast && hasFirst && shouldReSplitFirstOnly(firstVal)) {
          const nm = normalizeName(firstVal);
          lastVal  = String(nm.last  ?? '').trim();
          firstVal = String(nm.first ?? '').trim();
        }

        if (!(hasLast || hasFirst)){
          const sep = pickSeparateNames(row);
          if (sep.found && (sep.last || sep.first)) {
            lastVal  = sep.last;
            firstVal = sep.first;
          } else {
            let rawName = '';
            if (fullNameKey && row[fullNameKey] != null) {
              const candidate = String(row[fullNameKey]);
              if (!looksCompanyLike(candidate)) rawName = candidate;
            }
            if (!rawName) {
              const alt = row['氏名'] ?? row['姓名'] ?? row['名前'] ?? row['お名前'] ?? '';
              if (alt && !looksCompanyLike(String(alt))) rawName = alt;
            }
            if (rawName && !EMPTY_NAME_TOKENS.has(String(rawName).trim())) {
              const nm = normalizeName(rawName);
              lastVal  = String(nm.last  ?? '').trim();
              firstVal = String(nm.first ?? '').trim();
            }
          }
        }

        const swapped = maybeSwapName(lastVal, firstVal);
        lastVal = swapped.last;
        firstVal = swapped.first;

        // 最終補完は「未入力」
        if (!lastVal)  lastVal  = '未入力';
        if (!firstVal) firstVal = '未入力';

        if (outLastKey)  outRow[outLastKey]  = lastVal;
        if (outFirstKey) outRow[outFirstKey] = firstVal;

        // 3) Facebook URL → contact_url 反映
        if (sampleHeaders.includes('contact_url')) {
          const fb = extractFacebookUrlFromRow(row);
          if (fb) {
            const curUrl = String(outRow['contact_url'] ?? '').trim();
            if (!curUrl) {
              outRow['contact_url'] = fb;
            } else if (!/facebook\.com|fb\.com|fb\.me/i.test(curUrl)) {
              if (sampleHeaders.includes('notes')) appendToNotes(outRow, `Facebook: ${fb}`);
            }
          }
        }

        const hasAny = Object.values(outRow).some(v => (v!=null) && String(v).trim()!=='');
        if(hasAny) out.push(outRow);
      }

      const srcName = (sourceInput.files && sourceInput.files[0] && sourceInput.files[0].name) || '';
      saveCsvChunks(out, srcName, sampleHeaders);
    });

    fetchLocalSampleFallback();
  </script>
</body>
</html>
